// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"erm/internal/db/ent/medias"
	"erm/internal/db/ent/opinions"
	"erm/internal/db/ent/predicate"
	"erm/internal/db/ent/userlogins"
	"erm/internal/db/ent/users"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeMedias     = "Medias"
	TypeOpinions   = "Opinions"
	TypeUserlogins = "Userlogins"
	TypeUsers      = "Users"
)

// MediasMutation represents an operation that mutates the Medias nodes in the graph.
type MediasMutation struct {
	config
	op            Op
	typ           string
	id            *int
	oid           *string
	_path         *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Medias, error)
	predicates    []predicate.Medias
}

var _ ent.Mutation = (*MediasMutation)(nil)

// mediasOption allows management of the mutation configuration using functional options.
type mediasOption func(*MediasMutation)

// newMediasMutation creates new mutation for the Medias entity.
func newMediasMutation(c config, op Op, opts ...mediasOption) *MediasMutation {
	m := &MediasMutation{
		config:        c,
		op:            op,
		typ:           TypeMedias,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMediasID sets the ID field of the mutation.
func withMediasID(id int) mediasOption {
	return func(m *MediasMutation) {
		var (
			err   error
			once  sync.Once
			value *Medias
		)
		m.oldValue = func(ctx context.Context) (*Medias, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Medias.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMedias sets the old Medias of the mutation.
func withMedias(node *Medias) mediasOption {
	return func(m *MediasMutation) {
		m.oldValue = func(context.Context) (*Medias, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MediasMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MediasMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MediasMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MediasMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Medias.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOid sets the "oid" field.
func (m *MediasMutation) SetOid(s string) {
	m.oid = &s
}

// Oid returns the value of the "oid" field in the mutation.
func (m *MediasMutation) Oid() (r string, exists bool) {
	v := m.oid
	if v == nil {
		return
	}
	return *v, true
}

// OldOid returns the old "oid" field's value of the Medias entity.
// If the Medias object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediasMutation) OldOid(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOid: %w", err)
	}
	return oldValue.Oid, nil
}

// ResetOid resets all changes to the "oid" field.
func (m *MediasMutation) ResetOid() {
	m.oid = nil
}

// SetPath sets the "path" field.
func (m *MediasMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *MediasMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the Medias entity.
// If the Medias object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediasMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *MediasMutation) ResetPath() {
	m._path = nil
}

// Where appends a list predicates to the MediasMutation builder.
func (m *MediasMutation) Where(ps ...predicate.Medias) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MediasMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MediasMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Medias, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MediasMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MediasMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Medias).
func (m *MediasMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MediasMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.oid != nil {
		fields = append(fields, medias.FieldOid)
	}
	if m._path != nil {
		fields = append(fields, medias.FieldPath)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MediasMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case medias.FieldOid:
		return m.Oid()
	case medias.FieldPath:
		return m.Path()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MediasMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case medias.FieldOid:
		return m.OldOid(ctx)
	case medias.FieldPath:
		return m.OldPath(ctx)
	}
	return nil, fmt.Errorf("unknown Medias field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MediasMutation) SetField(name string, value ent.Value) error {
	switch name {
	case medias.FieldOid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOid(v)
		return nil
	case medias.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	}
	return fmt.Errorf("unknown Medias field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MediasMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MediasMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MediasMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Medias numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MediasMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MediasMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MediasMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Medias nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MediasMutation) ResetField(name string) error {
	switch name {
	case medias.FieldOid:
		m.ResetOid()
		return nil
	case medias.FieldPath:
		m.ResetPath()
		return nil
	}
	return fmt.Errorf("unknown Medias field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MediasMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MediasMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MediasMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MediasMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MediasMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MediasMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MediasMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Medias unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MediasMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Medias edge %s", name)
}

// OpinionsMutation represents an operation that mutates the Opinions nodes in the graph.
type OpinionsMutation struct {
	config
	op            Op
	typ           string
	id            *string
	name          *string
	telephone     *string
	time          *time.Time
	brand         *string
	resturtant    *string
	outlook1      *string
	outlook2      *string
	outlook3      *string
	waiting1      *string
	waiting2      *string
	ordering1     *string
	ordering2     *string
	ordering3     *string
	service1      *string
	service2      *string
	service3      *string
	qunility1     *string
	qunility2     *string
	qunility3     *string
	value1        *string
	value2        *string
	comment       *string
	rating        *int
	addrating     *int
	createdat     *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Opinions, error)
	predicates    []predicate.Opinions
}

var _ ent.Mutation = (*OpinionsMutation)(nil)

// opinionsOption allows management of the mutation configuration using functional options.
type opinionsOption func(*OpinionsMutation)

// newOpinionsMutation creates new mutation for the Opinions entity.
func newOpinionsMutation(c config, op Op, opts ...opinionsOption) *OpinionsMutation {
	m := &OpinionsMutation{
		config:        c,
		op:            op,
		typ:           TypeOpinions,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOpinionsID sets the ID field of the mutation.
func withOpinionsID(id string) opinionsOption {
	return func(m *OpinionsMutation) {
		var (
			err   error
			once  sync.Once
			value *Opinions
		)
		m.oldValue = func(ctx context.Context) (*Opinions, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Opinions.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOpinions sets the old Opinions of the mutation.
func withOpinions(node *Opinions) opinionsOption {
	return func(m *OpinionsMutation) {
		m.oldValue = func(context.Context) (*Opinions, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OpinionsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OpinionsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Opinions entities.
func (m *OpinionsMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OpinionsMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OpinionsMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Opinions.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *OpinionsMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OpinionsMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Opinions entity.
// If the Opinions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OpinionsMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OpinionsMutation) ResetName() {
	m.name = nil
}

// SetTelephone sets the "telephone" field.
func (m *OpinionsMutation) SetTelephone(s string) {
	m.telephone = &s
}

// Telephone returns the value of the "telephone" field in the mutation.
func (m *OpinionsMutation) Telephone() (r string, exists bool) {
	v := m.telephone
	if v == nil {
		return
	}
	return *v, true
}

// OldTelephone returns the old "telephone" field's value of the Opinions entity.
// If the Opinions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OpinionsMutation) OldTelephone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTelephone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTelephone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTelephone: %w", err)
	}
	return oldValue.Telephone, nil
}

// ResetTelephone resets all changes to the "telephone" field.
func (m *OpinionsMutation) ResetTelephone() {
	m.telephone = nil
}

// SetTime sets the "time" field.
func (m *OpinionsMutation) SetTime(t time.Time) {
	m.time = &t
}

// Time returns the value of the "time" field in the mutation.
func (m *OpinionsMutation) Time() (r time.Time, exists bool) {
	v := m.time
	if v == nil {
		return
	}
	return *v, true
}

// OldTime returns the old "time" field's value of the Opinions entity.
// If the Opinions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OpinionsMutation) OldTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTime: %w", err)
	}
	return oldValue.Time, nil
}

// ResetTime resets all changes to the "time" field.
func (m *OpinionsMutation) ResetTime() {
	m.time = nil
}

// SetBrand sets the "brand" field.
func (m *OpinionsMutation) SetBrand(s string) {
	m.brand = &s
}

// Brand returns the value of the "brand" field in the mutation.
func (m *OpinionsMutation) Brand() (r string, exists bool) {
	v := m.brand
	if v == nil {
		return
	}
	return *v, true
}

// OldBrand returns the old "brand" field's value of the Opinions entity.
// If the Opinions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OpinionsMutation) OldBrand(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBrand is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBrand requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrand: %w", err)
	}
	return oldValue.Brand, nil
}

// ResetBrand resets all changes to the "brand" field.
func (m *OpinionsMutation) ResetBrand() {
	m.brand = nil
}

// SetResturtant sets the "resturtant" field.
func (m *OpinionsMutation) SetResturtant(s string) {
	m.resturtant = &s
}

// Resturtant returns the value of the "resturtant" field in the mutation.
func (m *OpinionsMutation) Resturtant() (r string, exists bool) {
	v := m.resturtant
	if v == nil {
		return
	}
	return *v, true
}

// OldResturtant returns the old "resturtant" field's value of the Opinions entity.
// If the Opinions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OpinionsMutation) OldResturtant(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResturtant is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResturtant requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResturtant: %w", err)
	}
	return oldValue.Resturtant, nil
}

// ResetResturtant resets all changes to the "resturtant" field.
func (m *OpinionsMutation) ResetResturtant() {
	m.resturtant = nil
}

// SetOutlook1 sets the "outlook1" field.
func (m *OpinionsMutation) SetOutlook1(s string) {
	m.outlook1 = &s
}

// Outlook1 returns the value of the "outlook1" field in the mutation.
func (m *OpinionsMutation) Outlook1() (r string, exists bool) {
	v := m.outlook1
	if v == nil {
		return
	}
	return *v, true
}

// OldOutlook1 returns the old "outlook1" field's value of the Opinions entity.
// If the Opinions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OpinionsMutation) OldOutlook1(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutlook1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutlook1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutlook1: %w", err)
	}
	return oldValue.Outlook1, nil
}

// ResetOutlook1 resets all changes to the "outlook1" field.
func (m *OpinionsMutation) ResetOutlook1() {
	m.outlook1 = nil
}

// SetOutlook2 sets the "outlook2" field.
func (m *OpinionsMutation) SetOutlook2(s string) {
	m.outlook2 = &s
}

// Outlook2 returns the value of the "outlook2" field in the mutation.
func (m *OpinionsMutation) Outlook2() (r string, exists bool) {
	v := m.outlook2
	if v == nil {
		return
	}
	return *v, true
}

// OldOutlook2 returns the old "outlook2" field's value of the Opinions entity.
// If the Opinions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OpinionsMutation) OldOutlook2(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutlook2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutlook2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutlook2: %w", err)
	}
	return oldValue.Outlook2, nil
}

// ResetOutlook2 resets all changes to the "outlook2" field.
func (m *OpinionsMutation) ResetOutlook2() {
	m.outlook2 = nil
}

// SetOutlook3 sets the "outlook3" field.
func (m *OpinionsMutation) SetOutlook3(s string) {
	m.outlook3 = &s
}

// Outlook3 returns the value of the "outlook3" field in the mutation.
func (m *OpinionsMutation) Outlook3() (r string, exists bool) {
	v := m.outlook3
	if v == nil {
		return
	}
	return *v, true
}

// OldOutlook3 returns the old "outlook3" field's value of the Opinions entity.
// If the Opinions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OpinionsMutation) OldOutlook3(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutlook3 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutlook3 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutlook3: %w", err)
	}
	return oldValue.Outlook3, nil
}

// ResetOutlook3 resets all changes to the "outlook3" field.
func (m *OpinionsMutation) ResetOutlook3() {
	m.outlook3 = nil
}

// SetWaiting1 sets the "waiting1" field.
func (m *OpinionsMutation) SetWaiting1(s string) {
	m.waiting1 = &s
}

// Waiting1 returns the value of the "waiting1" field in the mutation.
func (m *OpinionsMutation) Waiting1() (r string, exists bool) {
	v := m.waiting1
	if v == nil {
		return
	}
	return *v, true
}

// OldWaiting1 returns the old "waiting1" field's value of the Opinions entity.
// If the Opinions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OpinionsMutation) OldWaiting1(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWaiting1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWaiting1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWaiting1: %w", err)
	}
	return oldValue.Waiting1, nil
}

// ResetWaiting1 resets all changes to the "waiting1" field.
func (m *OpinionsMutation) ResetWaiting1() {
	m.waiting1 = nil
}

// SetWaiting2 sets the "waiting2" field.
func (m *OpinionsMutation) SetWaiting2(s string) {
	m.waiting2 = &s
}

// Waiting2 returns the value of the "waiting2" field in the mutation.
func (m *OpinionsMutation) Waiting2() (r string, exists bool) {
	v := m.waiting2
	if v == nil {
		return
	}
	return *v, true
}

// OldWaiting2 returns the old "waiting2" field's value of the Opinions entity.
// If the Opinions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OpinionsMutation) OldWaiting2(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWaiting2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWaiting2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWaiting2: %w", err)
	}
	return oldValue.Waiting2, nil
}

// ResetWaiting2 resets all changes to the "waiting2" field.
func (m *OpinionsMutation) ResetWaiting2() {
	m.waiting2 = nil
}

// SetOrdering1 sets the "ordering1" field.
func (m *OpinionsMutation) SetOrdering1(s string) {
	m.ordering1 = &s
}

// Ordering1 returns the value of the "ordering1" field in the mutation.
func (m *OpinionsMutation) Ordering1() (r string, exists bool) {
	v := m.ordering1
	if v == nil {
		return
	}
	return *v, true
}

// OldOrdering1 returns the old "ordering1" field's value of the Opinions entity.
// If the Opinions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OpinionsMutation) OldOrdering1(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrdering1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrdering1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrdering1: %w", err)
	}
	return oldValue.Ordering1, nil
}

// ResetOrdering1 resets all changes to the "ordering1" field.
func (m *OpinionsMutation) ResetOrdering1() {
	m.ordering1 = nil
}

// SetOrdering2 sets the "ordering2" field.
func (m *OpinionsMutation) SetOrdering2(s string) {
	m.ordering2 = &s
}

// Ordering2 returns the value of the "ordering2" field in the mutation.
func (m *OpinionsMutation) Ordering2() (r string, exists bool) {
	v := m.ordering2
	if v == nil {
		return
	}
	return *v, true
}

// OldOrdering2 returns the old "ordering2" field's value of the Opinions entity.
// If the Opinions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OpinionsMutation) OldOrdering2(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrdering2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrdering2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrdering2: %w", err)
	}
	return oldValue.Ordering2, nil
}

// ResetOrdering2 resets all changes to the "ordering2" field.
func (m *OpinionsMutation) ResetOrdering2() {
	m.ordering2 = nil
}

// SetOrdering3 sets the "ordering3" field.
func (m *OpinionsMutation) SetOrdering3(s string) {
	m.ordering3 = &s
}

// Ordering3 returns the value of the "ordering3" field in the mutation.
func (m *OpinionsMutation) Ordering3() (r string, exists bool) {
	v := m.ordering3
	if v == nil {
		return
	}
	return *v, true
}

// OldOrdering3 returns the old "ordering3" field's value of the Opinions entity.
// If the Opinions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OpinionsMutation) OldOrdering3(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrdering3 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrdering3 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrdering3: %w", err)
	}
	return oldValue.Ordering3, nil
}

// ResetOrdering3 resets all changes to the "ordering3" field.
func (m *OpinionsMutation) ResetOrdering3() {
	m.ordering3 = nil
}

// SetService1 sets the "service1" field.
func (m *OpinionsMutation) SetService1(s string) {
	m.service1 = &s
}

// Service1 returns the value of the "service1" field in the mutation.
func (m *OpinionsMutation) Service1() (r string, exists bool) {
	v := m.service1
	if v == nil {
		return
	}
	return *v, true
}

// OldService1 returns the old "service1" field's value of the Opinions entity.
// If the Opinions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OpinionsMutation) OldService1(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldService1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldService1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldService1: %w", err)
	}
	return oldValue.Service1, nil
}

// ResetService1 resets all changes to the "service1" field.
func (m *OpinionsMutation) ResetService1() {
	m.service1 = nil
}

// SetService2 sets the "service2" field.
func (m *OpinionsMutation) SetService2(s string) {
	m.service2 = &s
}

// Service2 returns the value of the "service2" field in the mutation.
func (m *OpinionsMutation) Service2() (r string, exists bool) {
	v := m.service2
	if v == nil {
		return
	}
	return *v, true
}

// OldService2 returns the old "service2" field's value of the Opinions entity.
// If the Opinions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OpinionsMutation) OldService2(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldService2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldService2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldService2: %w", err)
	}
	return oldValue.Service2, nil
}

// ResetService2 resets all changes to the "service2" field.
func (m *OpinionsMutation) ResetService2() {
	m.service2 = nil
}

// SetService3 sets the "service3" field.
func (m *OpinionsMutation) SetService3(s string) {
	m.service3 = &s
}

// Service3 returns the value of the "service3" field in the mutation.
func (m *OpinionsMutation) Service3() (r string, exists bool) {
	v := m.service3
	if v == nil {
		return
	}
	return *v, true
}

// OldService3 returns the old "service3" field's value of the Opinions entity.
// If the Opinions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OpinionsMutation) OldService3(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldService3 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldService3 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldService3: %w", err)
	}
	return oldValue.Service3, nil
}

// ResetService3 resets all changes to the "service3" field.
func (m *OpinionsMutation) ResetService3() {
	m.service3 = nil
}

// SetQunility1 sets the "qunility1" field.
func (m *OpinionsMutation) SetQunility1(s string) {
	m.qunility1 = &s
}

// Qunility1 returns the value of the "qunility1" field in the mutation.
func (m *OpinionsMutation) Qunility1() (r string, exists bool) {
	v := m.qunility1
	if v == nil {
		return
	}
	return *v, true
}

// OldQunility1 returns the old "qunility1" field's value of the Opinions entity.
// If the Opinions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OpinionsMutation) OldQunility1(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQunility1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQunility1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQunility1: %w", err)
	}
	return oldValue.Qunility1, nil
}

// ResetQunility1 resets all changes to the "qunility1" field.
func (m *OpinionsMutation) ResetQunility1() {
	m.qunility1 = nil
}

// SetQunility2 sets the "qunility2" field.
func (m *OpinionsMutation) SetQunility2(s string) {
	m.qunility2 = &s
}

// Qunility2 returns the value of the "qunility2" field in the mutation.
func (m *OpinionsMutation) Qunility2() (r string, exists bool) {
	v := m.qunility2
	if v == nil {
		return
	}
	return *v, true
}

// OldQunility2 returns the old "qunility2" field's value of the Opinions entity.
// If the Opinions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OpinionsMutation) OldQunility2(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQunility2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQunility2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQunility2: %w", err)
	}
	return oldValue.Qunility2, nil
}

// ResetQunility2 resets all changes to the "qunility2" field.
func (m *OpinionsMutation) ResetQunility2() {
	m.qunility2 = nil
}

// SetQunility3 sets the "qunility3" field.
func (m *OpinionsMutation) SetQunility3(s string) {
	m.qunility3 = &s
}

// Qunility3 returns the value of the "qunility3" field in the mutation.
func (m *OpinionsMutation) Qunility3() (r string, exists bool) {
	v := m.qunility3
	if v == nil {
		return
	}
	return *v, true
}

// OldQunility3 returns the old "qunility3" field's value of the Opinions entity.
// If the Opinions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OpinionsMutation) OldQunility3(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQunility3 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQunility3 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQunility3: %w", err)
	}
	return oldValue.Qunility3, nil
}

// ResetQunility3 resets all changes to the "qunility3" field.
func (m *OpinionsMutation) ResetQunility3() {
	m.qunility3 = nil
}

// SetValue1 sets the "value1" field.
func (m *OpinionsMutation) SetValue1(s string) {
	m.value1 = &s
}

// Value1 returns the value of the "value1" field in the mutation.
func (m *OpinionsMutation) Value1() (r string, exists bool) {
	v := m.value1
	if v == nil {
		return
	}
	return *v, true
}

// OldValue1 returns the old "value1" field's value of the Opinions entity.
// If the Opinions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OpinionsMutation) OldValue1(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue1: %w", err)
	}
	return oldValue.Value1, nil
}

// ResetValue1 resets all changes to the "value1" field.
func (m *OpinionsMutation) ResetValue1() {
	m.value1 = nil
}

// SetValue2 sets the "value2" field.
func (m *OpinionsMutation) SetValue2(s string) {
	m.value2 = &s
}

// Value2 returns the value of the "value2" field in the mutation.
func (m *OpinionsMutation) Value2() (r string, exists bool) {
	v := m.value2
	if v == nil {
		return
	}
	return *v, true
}

// OldValue2 returns the old "value2" field's value of the Opinions entity.
// If the Opinions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OpinionsMutation) OldValue2(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue2: %w", err)
	}
	return oldValue.Value2, nil
}

// ResetValue2 resets all changes to the "value2" field.
func (m *OpinionsMutation) ResetValue2() {
	m.value2 = nil
}

// SetComment sets the "comment" field.
func (m *OpinionsMutation) SetComment(s string) {
	m.comment = &s
}

// Comment returns the value of the "comment" field in the mutation.
func (m *OpinionsMutation) Comment() (r string, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldComment returns the old "comment" field's value of the Opinions entity.
// If the Opinions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OpinionsMutation) OldComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComment: %w", err)
	}
	return oldValue.Comment, nil
}

// ResetComment resets all changes to the "comment" field.
func (m *OpinionsMutation) ResetComment() {
	m.comment = nil
}

// SetRating sets the "rating" field.
func (m *OpinionsMutation) SetRating(i int) {
	m.rating = &i
	m.addrating = nil
}

// Rating returns the value of the "rating" field in the mutation.
func (m *OpinionsMutation) Rating() (r int, exists bool) {
	v := m.rating
	if v == nil {
		return
	}
	return *v, true
}

// OldRating returns the old "rating" field's value of the Opinions entity.
// If the Opinions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OpinionsMutation) OldRating(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRating is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRating requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRating: %w", err)
	}
	return oldValue.Rating, nil
}

// AddRating adds i to the "rating" field.
func (m *OpinionsMutation) AddRating(i int) {
	if m.addrating != nil {
		*m.addrating += i
	} else {
		m.addrating = &i
	}
}

// AddedRating returns the value that was added to the "rating" field in this mutation.
func (m *OpinionsMutation) AddedRating() (r int, exists bool) {
	v := m.addrating
	if v == nil {
		return
	}
	return *v, true
}

// ResetRating resets all changes to the "rating" field.
func (m *OpinionsMutation) ResetRating() {
	m.rating = nil
	m.addrating = nil
}

// SetCreatedat sets the "createdat" field.
func (m *OpinionsMutation) SetCreatedat(t time.Time) {
	m.createdat = &t
}

// Createdat returns the value of the "createdat" field in the mutation.
func (m *OpinionsMutation) Createdat() (r time.Time, exists bool) {
	v := m.createdat
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedat returns the old "createdat" field's value of the Opinions entity.
// If the Opinions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OpinionsMutation) OldCreatedat(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedat: %w", err)
	}
	return oldValue.Createdat, nil
}

// ResetCreatedat resets all changes to the "createdat" field.
func (m *OpinionsMutation) ResetCreatedat() {
	m.createdat = nil
}

// Where appends a list predicates to the OpinionsMutation builder.
func (m *OpinionsMutation) Where(ps ...predicate.Opinions) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OpinionsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OpinionsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Opinions, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OpinionsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OpinionsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Opinions).
func (m *OpinionsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OpinionsMutation) Fields() []string {
	fields := make([]string, 0, 24)
	if m.name != nil {
		fields = append(fields, opinions.FieldName)
	}
	if m.telephone != nil {
		fields = append(fields, opinions.FieldTelephone)
	}
	if m.time != nil {
		fields = append(fields, opinions.FieldTime)
	}
	if m.brand != nil {
		fields = append(fields, opinions.FieldBrand)
	}
	if m.resturtant != nil {
		fields = append(fields, opinions.FieldResturtant)
	}
	if m.outlook1 != nil {
		fields = append(fields, opinions.FieldOutlook1)
	}
	if m.outlook2 != nil {
		fields = append(fields, opinions.FieldOutlook2)
	}
	if m.outlook3 != nil {
		fields = append(fields, opinions.FieldOutlook3)
	}
	if m.waiting1 != nil {
		fields = append(fields, opinions.FieldWaiting1)
	}
	if m.waiting2 != nil {
		fields = append(fields, opinions.FieldWaiting2)
	}
	if m.ordering1 != nil {
		fields = append(fields, opinions.FieldOrdering1)
	}
	if m.ordering2 != nil {
		fields = append(fields, opinions.FieldOrdering2)
	}
	if m.ordering3 != nil {
		fields = append(fields, opinions.FieldOrdering3)
	}
	if m.service1 != nil {
		fields = append(fields, opinions.FieldService1)
	}
	if m.service2 != nil {
		fields = append(fields, opinions.FieldService2)
	}
	if m.service3 != nil {
		fields = append(fields, opinions.FieldService3)
	}
	if m.qunility1 != nil {
		fields = append(fields, opinions.FieldQunility1)
	}
	if m.qunility2 != nil {
		fields = append(fields, opinions.FieldQunility2)
	}
	if m.qunility3 != nil {
		fields = append(fields, opinions.FieldQunility3)
	}
	if m.value1 != nil {
		fields = append(fields, opinions.FieldValue1)
	}
	if m.value2 != nil {
		fields = append(fields, opinions.FieldValue2)
	}
	if m.comment != nil {
		fields = append(fields, opinions.FieldComment)
	}
	if m.rating != nil {
		fields = append(fields, opinions.FieldRating)
	}
	if m.createdat != nil {
		fields = append(fields, opinions.FieldCreatedat)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OpinionsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case opinions.FieldName:
		return m.Name()
	case opinions.FieldTelephone:
		return m.Telephone()
	case opinions.FieldTime:
		return m.Time()
	case opinions.FieldBrand:
		return m.Brand()
	case opinions.FieldResturtant:
		return m.Resturtant()
	case opinions.FieldOutlook1:
		return m.Outlook1()
	case opinions.FieldOutlook2:
		return m.Outlook2()
	case opinions.FieldOutlook3:
		return m.Outlook3()
	case opinions.FieldWaiting1:
		return m.Waiting1()
	case opinions.FieldWaiting2:
		return m.Waiting2()
	case opinions.FieldOrdering1:
		return m.Ordering1()
	case opinions.FieldOrdering2:
		return m.Ordering2()
	case opinions.FieldOrdering3:
		return m.Ordering3()
	case opinions.FieldService1:
		return m.Service1()
	case opinions.FieldService2:
		return m.Service2()
	case opinions.FieldService3:
		return m.Service3()
	case opinions.FieldQunility1:
		return m.Qunility1()
	case opinions.FieldQunility2:
		return m.Qunility2()
	case opinions.FieldQunility3:
		return m.Qunility3()
	case opinions.FieldValue1:
		return m.Value1()
	case opinions.FieldValue2:
		return m.Value2()
	case opinions.FieldComment:
		return m.Comment()
	case opinions.FieldRating:
		return m.Rating()
	case opinions.FieldCreatedat:
		return m.Createdat()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OpinionsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case opinions.FieldName:
		return m.OldName(ctx)
	case opinions.FieldTelephone:
		return m.OldTelephone(ctx)
	case opinions.FieldTime:
		return m.OldTime(ctx)
	case opinions.FieldBrand:
		return m.OldBrand(ctx)
	case opinions.FieldResturtant:
		return m.OldResturtant(ctx)
	case opinions.FieldOutlook1:
		return m.OldOutlook1(ctx)
	case opinions.FieldOutlook2:
		return m.OldOutlook2(ctx)
	case opinions.FieldOutlook3:
		return m.OldOutlook3(ctx)
	case opinions.FieldWaiting1:
		return m.OldWaiting1(ctx)
	case opinions.FieldWaiting2:
		return m.OldWaiting2(ctx)
	case opinions.FieldOrdering1:
		return m.OldOrdering1(ctx)
	case opinions.FieldOrdering2:
		return m.OldOrdering2(ctx)
	case opinions.FieldOrdering3:
		return m.OldOrdering3(ctx)
	case opinions.FieldService1:
		return m.OldService1(ctx)
	case opinions.FieldService2:
		return m.OldService2(ctx)
	case opinions.FieldService3:
		return m.OldService3(ctx)
	case opinions.FieldQunility1:
		return m.OldQunility1(ctx)
	case opinions.FieldQunility2:
		return m.OldQunility2(ctx)
	case opinions.FieldQunility3:
		return m.OldQunility3(ctx)
	case opinions.FieldValue1:
		return m.OldValue1(ctx)
	case opinions.FieldValue2:
		return m.OldValue2(ctx)
	case opinions.FieldComment:
		return m.OldComment(ctx)
	case opinions.FieldRating:
		return m.OldRating(ctx)
	case opinions.FieldCreatedat:
		return m.OldCreatedat(ctx)
	}
	return nil, fmt.Errorf("unknown Opinions field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OpinionsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case opinions.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case opinions.FieldTelephone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTelephone(v)
		return nil
	case opinions.FieldTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTime(v)
		return nil
	case opinions.FieldBrand:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrand(v)
		return nil
	case opinions.FieldResturtant:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResturtant(v)
		return nil
	case opinions.FieldOutlook1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutlook1(v)
		return nil
	case opinions.FieldOutlook2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutlook2(v)
		return nil
	case opinions.FieldOutlook3:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutlook3(v)
		return nil
	case opinions.FieldWaiting1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWaiting1(v)
		return nil
	case opinions.FieldWaiting2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWaiting2(v)
		return nil
	case opinions.FieldOrdering1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrdering1(v)
		return nil
	case opinions.FieldOrdering2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrdering2(v)
		return nil
	case opinions.FieldOrdering3:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrdering3(v)
		return nil
	case opinions.FieldService1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetService1(v)
		return nil
	case opinions.FieldService2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetService2(v)
		return nil
	case opinions.FieldService3:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetService3(v)
		return nil
	case opinions.FieldQunility1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQunility1(v)
		return nil
	case opinions.FieldQunility2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQunility2(v)
		return nil
	case opinions.FieldQunility3:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQunility3(v)
		return nil
	case opinions.FieldValue1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue1(v)
		return nil
	case opinions.FieldValue2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue2(v)
		return nil
	case opinions.FieldComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComment(v)
		return nil
	case opinions.FieldRating:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRating(v)
		return nil
	case opinions.FieldCreatedat:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedat(v)
		return nil
	}
	return fmt.Errorf("unknown Opinions field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OpinionsMutation) AddedFields() []string {
	var fields []string
	if m.addrating != nil {
		fields = append(fields, opinions.FieldRating)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OpinionsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case opinions.FieldRating:
		return m.AddedRating()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OpinionsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case opinions.FieldRating:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRating(v)
		return nil
	}
	return fmt.Errorf("unknown Opinions numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OpinionsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OpinionsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OpinionsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Opinions nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OpinionsMutation) ResetField(name string) error {
	switch name {
	case opinions.FieldName:
		m.ResetName()
		return nil
	case opinions.FieldTelephone:
		m.ResetTelephone()
		return nil
	case opinions.FieldTime:
		m.ResetTime()
		return nil
	case opinions.FieldBrand:
		m.ResetBrand()
		return nil
	case opinions.FieldResturtant:
		m.ResetResturtant()
		return nil
	case opinions.FieldOutlook1:
		m.ResetOutlook1()
		return nil
	case opinions.FieldOutlook2:
		m.ResetOutlook2()
		return nil
	case opinions.FieldOutlook3:
		m.ResetOutlook3()
		return nil
	case opinions.FieldWaiting1:
		m.ResetWaiting1()
		return nil
	case opinions.FieldWaiting2:
		m.ResetWaiting2()
		return nil
	case opinions.FieldOrdering1:
		m.ResetOrdering1()
		return nil
	case opinions.FieldOrdering2:
		m.ResetOrdering2()
		return nil
	case opinions.FieldOrdering3:
		m.ResetOrdering3()
		return nil
	case opinions.FieldService1:
		m.ResetService1()
		return nil
	case opinions.FieldService2:
		m.ResetService2()
		return nil
	case opinions.FieldService3:
		m.ResetService3()
		return nil
	case opinions.FieldQunility1:
		m.ResetQunility1()
		return nil
	case opinions.FieldQunility2:
		m.ResetQunility2()
		return nil
	case opinions.FieldQunility3:
		m.ResetQunility3()
		return nil
	case opinions.FieldValue1:
		m.ResetValue1()
		return nil
	case opinions.FieldValue2:
		m.ResetValue2()
		return nil
	case opinions.FieldComment:
		m.ResetComment()
		return nil
	case opinions.FieldRating:
		m.ResetRating()
		return nil
	case opinions.FieldCreatedat:
		m.ResetCreatedat()
		return nil
	}
	return fmt.Errorf("unknown Opinions field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OpinionsMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OpinionsMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OpinionsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OpinionsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OpinionsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OpinionsMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OpinionsMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Opinions unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OpinionsMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Opinions edge %s", name)
}

// UserloginsMutation represents an operation that mutates the Userlogins nodes in the graph.
type UserloginsMutation struct {
	config
	op            Op
	typ           string
	id            *int
	username      *string
	password      *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Userlogins, error)
	predicates    []predicate.Userlogins
}

var _ ent.Mutation = (*UserloginsMutation)(nil)

// userloginsOption allows management of the mutation configuration using functional options.
type userloginsOption func(*UserloginsMutation)

// newUserloginsMutation creates new mutation for the Userlogins entity.
func newUserloginsMutation(c config, op Op, opts ...userloginsOption) *UserloginsMutation {
	m := &UserloginsMutation{
		config:        c,
		op:            op,
		typ:           TypeUserlogins,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserloginsID sets the ID field of the mutation.
func withUserloginsID(id int) userloginsOption {
	return func(m *UserloginsMutation) {
		var (
			err   error
			once  sync.Once
			value *Userlogins
		)
		m.oldValue = func(ctx context.Context) (*Userlogins, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Userlogins.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserlogins sets the old Userlogins of the mutation.
func withUserlogins(node *Userlogins) userloginsOption {
	return func(m *UserloginsMutation) {
		m.oldValue = func(context.Context) (*Userlogins, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserloginsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserloginsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserloginsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserloginsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Userlogins.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUsername sets the "username" field.
func (m *UserloginsMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserloginsMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the Userlogins entity.
// If the Userlogins object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserloginsMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserloginsMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *UserloginsMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserloginsMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Userlogins entity.
// If the Userlogins object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserloginsMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserloginsMutation) ResetPassword() {
	m.password = nil
}

// Where appends a list predicates to the UserloginsMutation builder.
func (m *UserloginsMutation) Where(ps ...predicate.Userlogins) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserloginsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserloginsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Userlogins, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserloginsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserloginsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Userlogins).
func (m *UserloginsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserloginsMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.username != nil {
		fields = append(fields, userlogins.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, userlogins.FieldPassword)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserloginsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userlogins.FieldUsername:
		return m.Username()
	case userlogins.FieldPassword:
		return m.Password()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserloginsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userlogins.FieldUsername:
		return m.OldUsername(ctx)
	case userlogins.FieldPassword:
		return m.OldPassword(ctx)
	}
	return nil, fmt.Errorf("unknown Userlogins field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserloginsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userlogins.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case userlogins.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	}
	return fmt.Errorf("unknown Userlogins field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserloginsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserloginsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserloginsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Userlogins numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserloginsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserloginsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserloginsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Userlogins nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserloginsMutation) ResetField(name string) error {
	switch name {
	case userlogins.FieldUsername:
		m.ResetUsername()
		return nil
	case userlogins.FieldPassword:
		m.ResetPassword()
		return nil
	}
	return fmt.Errorf("unknown Userlogins field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserloginsMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserloginsMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserloginsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserloginsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserloginsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserloginsMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserloginsMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Userlogins unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserloginsMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Userlogins edge %s", name)
}

// UsersMutation represents an operation that mutates the Users nodes in the graph.
type UsersMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	email          *string
	password_hash  *string
	user_status    *int
	adduser_status *int
	user_role      *string
	updated_at     *time.Time
	created_at     *time.Time
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*Users, error)
	predicates     []predicate.Users
}

var _ ent.Mutation = (*UsersMutation)(nil)

// usersOption allows management of the mutation configuration using functional options.
type usersOption func(*UsersMutation)

// newUsersMutation creates new mutation for the Users entity.
func newUsersMutation(c config, op Op, opts ...usersOption) *UsersMutation {
	m := &UsersMutation{
		config:        c,
		op:            op,
		typ:           TypeUsers,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUsersID sets the ID field of the mutation.
func withUsersID(id uuid.UUID) usersOption {
	return func(m *UsersMutation) {
		var (
			err   error
			once  sync.Once
			value *Users
		)
		m.oldValue = func(ctx context.Context) (*Users, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Users.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUsers sets the old Users of the mutation.
func withUsers(node *Users) usersOption {
	return func(m *UsersMutation) {
		m.oldValue = func(context.Context) (*Users, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UsersMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UsersMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Users entities.
func (m *UsersMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UsersMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UsersMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Users.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmail sets the "email" field.
func (m *UsersMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UsersMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Users entity.
// If the Users object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsersMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UsersMutation) ResetEmail() {
	m.email = nil
}

// SetPasswordHash sets the "password_hash" field.
func (m *UsersMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *UsersMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the Users entity.
// If the Users object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsersMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *UsersMutation) ResetPasswordHash() {
	m.password_hash = nil
}

// SetUserStatus sets the "user_status" field.
func (m *UsersMutation) SetUserStatus(i int) {
	m.user_status = &i
	m.adduser_status = nil
}

// UserStatus returns the value of the "user_status" field in the mutation.
func (m *UsersMutation) UserStatus() (r int, exists bool) {
	v := m.user_status
	if v == nil {
		return
	}
	return *v, true
}

// OldUserStatus returns the old "user_status" field's value of the Users entity.
// If the Users object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsersMutation) OldUserStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserStatus: %w", err)
	}
	return oldValue.UserStatus, nil
}

// AddUserStatus adds i to the "user_status" field.
func (m *UsersMutation) AddUserStatus(i int) {
	if m.adduser_status != nil {
		*m.adduser_status += i
	} else {
		m.adduser_status = &i
	}
}

// AddedUserStatus returns the value that was added to the "user_status" field in this mutation.
func (m *UsersMutation) AddedUserStatus() (r int, exists bool) {
	v := m.adduser_status
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserStatus resets all changes to the "user_status" field.
func (m *UsersMutation) ResetUserStatus() {
	m.user_status = nil
	m.adduser_status = nil
}

// SetUserRole sets the "user_role" field.
func (m *UsersMutation) SetUserRole(s string) {
	m.user_role = &s
}

// UserRole returns the value of the "user_role" field in the mutation.
func (m *UsersMutation) UserRole() (r string, exists bool) {
	v := m.user_role
	if v == nil {
		return
	}
	return *v, true
}

// OldUserRole returns the old "user_role" field's value of the Users entity.
// If the Users object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsersMutation) OldUserRole(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserRole: %w", err)
	}
	return oldValue.UserRole, nil
}

// ResetUserRole resets all changes to the "user_role" field.
func (m *UsersMutation) ResetUserRole() {
	m.user_role = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UsersMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UsersMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Users entity.
// If the Users object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsersMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UsersMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UsersMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UsersMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Users entity.
// If the Users object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsersMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UsersMutation) ResetCreatedAt() {
	m.created_at = nil
}

// Where appends a list predicates to the UsersMutation builder.
func (m *UsersMutation) Where(ps ...predicate.Users) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UsersMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UsersMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Users, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UsersMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UsersMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Users).
func (m *UsersMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UsersMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.email != nil {
		fields = append(fields, users.FieldEmail)
	}
	if m.password_hash != nil {
		fields = append(fields, users.FieldPasswordHash)
	}
	if m.user_status != nil {
		fields = append(fields, users.FieldUserStatus)
	}
	if m.user_role != nil {
		fields = append(fields, users.FieldUserRole)
	}
	if m.updated_at != nil {
		fields = append(fields, users.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, users.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UsersMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case users.FieldEmail:
		return m.Email()
	case users.FieldPasswordHash:
		return m.PasswordHash()
	case users.FieldUserStatus:
		return m.UserStatus()
	case users.FieldUserRole:
		return m.UserRole()
	case users.FieldUpdatedAt:
		return m.UpdatedAt()
	case users.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UsersMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case users.FieldEmail:
		return m.OldEmail(ctx)
	case users.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case users.FieldUserStatus:
		return m.OldUserStatus(ctx)
	case users.FieldUserRole:
		return m.OldUserRole(ctx)
	case users.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case users.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Users field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UsersMutation) SetField(name string, value ent.Value) error {
	switch name {
	case users.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case users.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case users.FieldUserStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserStatus(v)
		return nil
	case users.FieldUserRole:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserRole(v)
		return nil
	case users.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case users.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Users field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UsersMutation) AddedFields() []string {
	var fields []string
	if m.adduser_status != nil {
		fields = append(fields, users.FieldUserStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UsersMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case users.FieldUserStatus:
		return m.AddedUserStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UsersMutation) AddField(name string, value ent.Value) error {
	switch name {
	case users.FieldUserStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Users numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UsersMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UsersMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UsersMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Users nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UsersMutation) ResetField(name string) error {
	switch name {
	case users.FieldEmail:
		m.ResetEmail()
		return nil
	case users.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case users.FieldUserStatus:
		m.ResetUserStatus()
		return nil
	case users.FieldUserRole:
		m.ResetUserRole()
		return nil
	case users.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case users.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Users field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UsersMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UsersMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UsersMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UsersMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UsersMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UsersMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UsersMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Users unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UsersMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Users edge %s", name)
}
